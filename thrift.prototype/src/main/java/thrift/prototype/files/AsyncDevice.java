/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package thrift.prototype.files;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class AsyncDevice {

  public interface Iface {

    public String connect(String userName, String passWord) throws LoginFailed, TException;

    public void disconnect(String key) throws TException;

    public void setMessage(String key, String OperationHandleKey, String message) throws TException;

    public String getMessage(String key, String OperationHandleKey) throws TException;

    public void program(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout) throws TException;

    public void HandleCancel(String key, String OperationHandleKey) throws TException;

    public void HandleGet(String key, String OperationHandleKey) throws TException;

    public String HandleGetState(String key, String OperationHandleKey) throws TException;

  }

  public interface AsyncIface {

    public void connect(String userName, String passWord, AsyncMethodCallback<AsyncClient.connect_call> resultHandler) throws TException;

    public void disconnect(String key, AsyncMethodCallback<AsyncClient.disconnect_call> resultHandler) throws TException;

    public void setMessage(String key, String OperationHandleKey, String message, AsyncMethodCallback<AsyncClient.setMessage_call> resultHandler) throws TException;

    public void getMessage(String key, String OperationHandleKey, AsyncMethodCallback<AsyncClient.getMessage_call> resultHandler) throws TException;

    public void program(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout, AsyncMethodCallback<AsyncClient.program_call> resultHandler) throws TException;

    public void HandleCancel(String key, String OperationHandleKey, AsyncMethodCallback<AsyncClient.HandleCancel_call> resultHandler) throws TException;

    public void HandleGet(String key, String OperationHandleKey, AsyncMethodCallback<AsyncClient.HandleGet_call> resultHandler) throws TException;

    public void HandleGetState(String key, String OperationHandleKey, AsyncMethodCallback<AsyncClient.HandleGetState_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public String connect(String userName, String passWord) throws LoginFailed, TException
    {
      send_connect(userName, passWord);
      return recv_connect();
    }

    public void send_connect(String userName, String passWord) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("connect", TMessageType.CALL, ++seqid_));
      connect_args args = new connect_args();
      args.setUserName(userName);
      args.setPassWord(passWord);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_connect() throws LoginFailed, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "connect failed: out of sequence response");
      }
      connect_result result = new connect_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.lf != null) {
        throw result.lf;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "connect failed: unknown result");
    }

    public void disconnect(String key) throws TException
    {
      send_disconnect(key);
    }

    public void send_disconnect(String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("disconnect", TMessageType.CALL, ++seqid_));
      disconnect_args args = new disconnect_args();
      args.setKey(key);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void setMessage(String key, String OperationHandleKey, String message) throws TException
    {
      send_setMessage(key, OperationHandleKey, message);
      recv_setMessage();
    }

    public void send_setMessage(String key, String OperationHandleKey, String message) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setMessage", TMessageType.CALL, ++seqid_));
      setMessage_args args = new setMessage_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.setMessage(message);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setMessage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setMessage failed: out of sequence response");
      }
      setMessage_result result = new setMessage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public String getMessage(String key, String OperationHandleKey) throws TException
    {
      send_getMessage(key, OperationHandleKey);
      return recv_getMessage();
    }

    public void send_getMessage(String key, String OperationHandleKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getMessage", TMessageType.CALL, ++seqid_));
      getMessage_args args = new getMessage_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getMessage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getMessage failed: out of sequence response");
      }
      getMessage_result result = new getMessage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getMessage failed: unknown result");
    }

    public void program(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout) throws TException
    {
      send_program(key, OperationHandleKey, bytes, description, timeout);
      recv_program();
    }

    public void send_program(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("program", TMessageType.CALL, ++seqid_));
      program_args args = new program_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.setBytes(bytes);
      args.setDescription(description);
      args.setTimeout(timeout);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_program() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "program failed: out of sequence response");
      }
      program_result result = new program_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void HandleCancel(String key, String OperationHandleKey) throws TException
    {
      send_HandleCancel(key, OperationHandleKey);
    }

    public void send_HandleCancel(String key, String OperationHandleKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("HandleCancel", TMessageType.CALL, ++seqid_));
      HandleCancel_args args = new HandleCancel_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void HandleGet(String key, String OperationHandleKey) throws TException
    {
      send_HandleGet(key, OperationHandleKey);
      recv_HandleGet();
    }

    public void send_HandleGet(String key, String OperationHandleKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("HandleGet", TMessageType.CALL, ++seqid_));
      HandleGet_args args = new HandleGet_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_HandleGet() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "HandleGet failed: out of sequence response");
      }
      HandleGet_result result = new HandleGet_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public String HandleGetState(String key, String OperationHandleKey) throws TException
    {
      send_HandleGetState(key, OperationHandleKey);
      return recv_HandleGetState();
    }

    public void send_HandleGetState(String key, String OperationHandleKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("HandleGetState", TMessageType.CALL, ++seqid_));
      HandleGetState_args args = new HandleGetState_args();
      args.setKey(key);
      args.setOperationHandleKey(OperationHandleKey);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_HandleGetState() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "HandleGetState failed: out of sequence response");
      }
      HandleGetState_result result = new HandleGetState_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "HandleGetState failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void connect(String userName, String passWord, AsyncMethodCallback<connect_call> resultHandler) throws TException {
      checkReady();
      connect_call method_call = new connect_call(userName, passWord, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class connect_call extends TAsyncMethodCall {
      private String userName;
      private String passWord;
      public connect_call(String userName, String passWord, AsyncMethodCallback<connect_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.userName = userName;
        this.passWord = passWord;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("connect", TMessageType.CALL, 0));
        connect_args args = new connect_args();
        args.setUserName(userName);
        args.setPassWord(passWord);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws LoginFailed, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_connect();
      }
    }

    public void disconnect(String key, AsyncMethodCallback<disconnect_call> resultHandler) throws TException {
      checkReady();
      disconnect_call method_call = new disconnect_call(key, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class disconnect_call extends TAsyncMethodCall {
      private String key;
      public disconnect_call(String key, AsyncMethodCallback<disconnect_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, true);
        this.key = key;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("disconnect", TMessageType.CALL, 0));
        disconnect_args args = new disconnect_args();
        args.setKey(key);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
      }
    }

    public void setMessage(String key, String OperationHandleKey, String message, AsyncMethodCallback<setMessage_call> resultHandler) throws TException {
      checkReady();
      setMessage_call method_call = new setMessage_call(key, OperationHandleKey, message, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setMessage_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      private String message;
      public setMessage_call(String key, String OperationHandleKey, String message, AsyncMethodCallback<setMessage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
        this.message = message;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setMessage", TMessageType.CALL, 0));
        setMessage_args args = new setMessage_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.setMessage(message);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setMessage();
      }
    }

    public void getMessage(String key, String OperationHandleKey, AsyncMethodCallback<getMessage_call> resultHandler) throws TException {
      checkReady();
      getMessage_call method_call = new getMessage_call(key, OperationHandleKey, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getMessage_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      public getMessage_call(String key, String OperationHandleKey, AsyncMethodCallback<getMessage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getMessage", TMessageType.CALL, 0));
        getMessage_args args = new getMessage_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getMessage();
      }
    }

    public void program(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout, AsyncMethodCallback<program_call> resultHandler) throws TException {
      checkReady();
      program_call method_call = new program_call(key, OperationHandleKey, bytes, description, timeout, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class program_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      private List<ByteBuffer> bytes;
      private String description;
      private long timeout;
      public program_call(String key, String OperationHandleKey, List<ByteBuffer> bytes, String description, long timeout, AsyncMethodCallback<program_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
        this.bytes = bytes;
        this.description = description;
        this.timeout = timeout;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("program", TMessageType.CALL, 0));
        program_args args = new program_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.setBytes(bytes);
        args.setDescription(description);
        args.setTimeout(timeout);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_program();
      }
    }

    public void HandleCancel(String key, String OperationHandleKey, AsyncMethodCallback<HandleCancel_call> resultHandler) throws TException {
      checkReady();
      HandleCancel_call method_call = new HandleCancel_call(key, OperationHandleKey, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class HandleCancel_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      public HandleCancel_call(String key, String OperationHandleKey, AsyncMethodCallback<HandleCancel_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, true);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("HandleCancel", TMessageType.CALL, 0));
        HandleCancel_args args = new HandleCancel_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
      }
    }

    public void HandleGet(String key, String OperationHandleKey, AsyncMethodCallback<HandleGet_call> resultHandler) throws TException {
      checkReady();
      HandleGet_call method_call = new HandleGet_call(key, OperationHandleKey, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class HandleGet_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      public HandleGet_call(String key, String OperationHandleKey, AsyncMethodCallback<HandleGet_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("HandleGet", TMessageType.CALL, 0));
        HandleGet_args args = new HandleGet_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_HandleGet();
      }
    }

    public void HandleGetState(String key, String OperationHandleKey, AsyncMethodCallback<HandleGetState_call> resultHandler) throws TException {
      checkReady();
      HandleGetState_call method_call = new HandleGetState_call(key, OperationHandleKey, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class HandleGetState_call extends TAsyncMethodCall {
      private String key;
      private String OperationHandleKey;
      public HandleGetState_call(String key, String OperationHandleKey, AsyncMethodCallback<HandleGetState_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.key = key;
        this.OperationHandleKey = OperationHandleKey;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("HandleGetState", TMessageType.CALL, 0));
        HandleGetState_args args = new HandleGetState_args();
        args.setKey(key);
        args.setOperationHandleKey(OperationHandleKey);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_HandleGetState();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("connect", new connect());
      processMap_.put("disconnect", new disconnect());
      processMap_.put("setMessage", new setMessage());
      processMap_.put("getMessage", new getMessage());
      processMap_.put("program", new program());
      processMap_.put("HandleCancel", new HandleCancel());
      processMap_.put("HandleGet", new HandleGet());
      processMap_.put("HandleGetState", new HandleGetState());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class connect implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        connect_args args = new connect_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("connect", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        connect_result result = new connect_result();
        try {
          result.success = iface_.connect(args.userName, args.passWord);
        } catch (LoginFailed lf) {
          result.lf = lf;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing connect", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing connect");
          oprot.writeMessageBegin(new TMessage("connect", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("connect", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class disconnect implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        disconnect_args args = new disconnect_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("disconnect", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        iface_.disconnect(args.key);
        return;
      }
    }

    private class setMessage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setMessage_args args = new setMessage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setMessage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setMessage_result result = new setMessage_result();
        iface_.setMessage(args.key, args.OperationHandleKey, args.message);
        oprot.writeMessageBegin(new TMessage("setMessage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getMessage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getMessage_args args = new getMessage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getMessage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getMessage_result result = new getMessage_result();
        result.success = iface_.getMessage(args.key, args.OperationHandleKey);
        oprot.writeMessageBegin(new TMessage("getMessage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class program implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        program_args args = new program_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("program", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        program_result result = new program_result();
        iface_.program(args.key, args.OperationHandleKey, args.bytes, args.description, args.timeout);
        oprot.writeMessageBegin(new TMessage("program", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class HandleCancel implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        HandleCancel_args args = new HandleCancel_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("HandleCancel", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        iface_.HandleCancel(args.key, args.OperationHandleKey);
        return;
      }
    }

    private class HandleGet implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        HandleGet_args args = new HandleGet_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("HandleGet", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        HandleGet_result result = new HandleGet_result();
        iface_.HandleGet(args.key, args.OperationHandleKey);
        oprot.writeMessageBegin(new TMessage("HandleGet", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class HandleGetState implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        HandleGetState_args args = new HandleGetState_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("HandleGetState", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        HandleGetState_result result = new HandleGetState_result();
        result.success = iface_.HandleGetState(args.key, args.OperationHandleKey);
        oprot.writeMessageBegin(new TMessage("HandleGetState", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class connect_args implements TBase<connect_args, connect_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("connect_args");

    private static final TField USER_NAME_FIELD_DESC = new TField("userName", TType.STRING, (short)1);
    private static final TField PASS_WORD_FIELD_DESC = new TField("passWord", TType.STRING, (short)2);

    public String userName;
    public String passWord;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      USER_NAME((short)1, "userName"),
      PASS_WORD((short)2, "passWord");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // USER_NAME
            return USER_NAME;
          case 2: // PASS_WORD
            return PASS_WORD;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.USER_NAME, new FieldMetaData("userName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PASS_WORD, new FieldMetaData("passWord", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(connect_args.class, metaDataMap);
    }

    public connect_args() {
    }

    public connect_args(
      String userName,
      String passWord)
    {
      this();
      this.userName = userName;
      this.passWord = passWord;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connect_args(connect_args other) {
      if (other.isSetUserName()) {
        this.userName = other.userName;
      }
      if (other.isSetPassWord()) {
        this.passWord = other.passWord;
      }
    }

    public connect_args deepCopy() {
      return new connect_args(this);
    }

    @Deprecated
    public connect_args clone() {
      return new connect_args(this);
    }

    @Override
    public void clear() {
      this.userName = null;
      this.passWord = null;
    }

    public String getUserName() {
      return this.userName;
    }

    public connect_args setUserName(String userName) {
      this.userName = userName;
      return this;
    }

    public void unsetUserName() {
      this.userName = null;
    }

    /** Returns true if field userName is set (has been asigned a value) and false otherwise */
    public boolean isSetUserName() {
      return this.userName != null;
    }

    public void setUserNameIsSet(boolean value) {
      if (!value) {
        this.userName = null;
      }
    }

    public String getPassWord() {
      return this.passWord;
    }

    public connect_args setPassWord(String passWord) {
      this.passWord = passWord;
      return this;
    }

    public void unsetPassWord() {
      this.passWord = null;
    }

    /** Returns true if field passWord is set (has been asigned a value) and false otherwise */
    public boolean isSetPassWord() {
      return this.passWord != null;
    }

    public void setPassWordIsSet(boolean value) {
      if (!value) {
        this.passWord = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case USER_NAME:
        if (value == null) {
          unsetUserName();
        } else {
          setUserName((String)value);
        }
        break;

      case PASS_WORD:
        if (value == null) {
          unsetPassWord();
        } else {
          setPassWord((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case USER_NAME:
        return getUserName();

      case PASS_WORD:
        return getPassWord();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case USER_NAME:
        return isSetUserName();
      case PASS_WORD:
        return isSetPassWord();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connect_args)
        return this.equals((connect_args)that);
      return false;
    }

    public boolean equals(connect_args that) {
      if (that == null)
        return false;

      boolean this_present_userName = true && this.isSetUserName();
      boolean that_present_userName = true && that.isSetUserName();
      if (this_present_userName || that_present_userName) {
        if (!(this_present_userName && that_present_userName))
          return false;
        if (!this.userName.equals(that.userName))
          return false;
      }

      boolean this_present_passWord = true && this.isSetPassWord();
      boolean that_present_passWord = true && that.isSetPassWord();
      if (this_present_passWord || that_present_passWord) {
        if (!(this_present_passWord && that_present_passWord))
          return false;
        if (!this.passWord.equals(that.passWord))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(connect_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      connect_args typedOther = (connect_args)other;

      lastComparison = Boolean.valueOf(isSetUserName()).compareTo(typedOther.isSetUserName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUserName()) {        lastComparison = TBaseHelper.compareTo(this.userName, typedOther.userName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPassWord()).compareTo(typedOther.isSetPassWord());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPassWord()) {        lastComparison = TBaseHelper.compareTo(this.passWord, typedOther.passWord);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // USER_NAME
            if (field.type == TType.STRING) {
              this.userName = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PASS_WORD
            if (field.type == TType.STRING) {
              this.passWord = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.userName != null) {
        oprot.writeFieldBegin(USER_NAME_FIELD_DESC);
        oprot.writeString(this.userName);
        oprot.writeFieldEnd();
      }
      if (this.passWord != null) {
        oprot.writeFieldBegin(PASS_WORD_FIELD_DESC);
        oprot.writeString(this.passWord);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connect_args(");
      boolean first = true;

      sb.append("userName:");
      if (this.userName == null) {
        sb.append("null");
      } else {
        sb.append(this.userName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("passWord:");
      if (this.passWord == null) {
        sb.append("null");
      } else {
        sb.append(this.passWord);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class connect_result implements TBase<connect_result, connect_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("connect_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField LF_FIELD_DESC = new TField("lf", TType.STRUCT, (short)1);

    public String success;
    public LoginFailed lf;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      LF((short)1, "lf");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // LF
            return LF;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.LF, new FieldMetaData("lf", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(connect_result.class, metaDataMap);
    }

    public connect_result() {
    }

    public connect_result(
      String success,
      LoginFailed lf)
    {
      this();
      this.success = success;
      this.lf = lf;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public connect_result(connect_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetLf()) {
        this.lf = new LoginFailed(other.lf);
      }
    }

    public connect_result deepCopy() {
      return new connect_result(this);
    }

    @Deprecated
    public connect_result clone() {
      return new connect_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.lf = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public connect_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public LoginFailed getLf() {
      return this.lf;
    }

    public connect_result setLf(LoginFailed lf) {
      this.lf = lf;
      return this;
    }

    public void unsetLf() {
      this.lf = null;
    }

    /** Returns true if field lf is set (has been asigned a value) and false otherwise */
    public boolean isSetLf() {
      return this.lf != null;
    }

    public void setLfIsSet(boolean value) {
      if (!value) {
        this.lf = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case LF:
        if (value == null) {
          unsetLf();
        } else {
          setLf((LoginFailed)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case LF:
        return getLf();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case LF:
        return isSetLf();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof connect_result)
        return this.equals((connect_result)that);
      return false;
    }

    public boolean equals(connect_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_lf = true && this.isSetLf();
      boolean that_present_lf = true && that.isSetLf();
      if (this_present_lf || that_present_lf) {
        if (!(this_present_lf && that_present_lf))
          return false;
        if (!this.lf.equals(that.lf))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(connect_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      connect_result typedOther = (connect_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLf()).compareTo(typedOther.isSetLf());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLf()) {        lastComparison = TBaseHelper.compareTo(this.lf, typedOther.lf);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // LF
            if (field.type == TType.STRUCT) {
              this.lf = new LoginFailed();
              this.lf.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetLf()) {
        oprot.writeFieldBegin(LF_FIELD_DESC);
        this.lf.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("connect_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("lf:");
      if (this.lf == null) {
        sb.append("null");
      } else {
        sb.append(this.lf);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class disconnect_args implements TBase<disconnect_args, disconnect_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("disconnect_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);

    public String key;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(disconnect_args.class, metaDataMap);
    }

    public disconnect_args() {
    }

    public disconnect_args(
      String key)
    {
      this();
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public disconnect_args(disconnect_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    public disconnect_args deepCopy() {
      return new disconnect_args(this);
    }

    @Deprecated
    public disconnect_args clone() {
      return new disconnect_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
    }

    public String getKey() {
      return this.key;
    }

    public disconnect_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof disconnect_args)
        return this.equals((disconnect_args)that);
      return false;
    }

    public boolean equals(disconnect_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(disconnect_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      disconnect_args typedOther = (disconnect_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("disconnect_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setMessage_args implements TBase<setMessage_args, setMessage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setMessage_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);
    private static final TField MESSAGE_FIELD_DESC = new TField("message", TType.STRING, (short)3);

    public String key;
    public String OperationHandleKey;
    public String message;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey"),
      MESSAGE((short)3, "message");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          case 3: // MESSAGE
            return MESSAGE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MESSAGE, new FieldMetaData("message", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setMessage_args.class, metaDataMap);
    }

    public setMessage_args() {
    }

    public setMessage_args(
      String key,
      String OperationHandleKey,
      String message)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
      this.message = message;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setMessage_args(setMessage_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
      if (other.isSetMessage()) {
        this.message = other.message;
      }
    }

    public setMessage_args deepCopy() {
      return new setMessage_args(this);
    }

    @Deprecated
    public setMessage_args clone() {
      return new setMessage_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
      this.message = null;
    }

    public String getKey() {
      return this.key;
    }

    public setMessage_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public setMessage_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public String getMessage() {
      return this.message;
    }

    public setMessage_args setMessage(String message) {
      this.message = message;
      return this;
    }

    public void unsetMessage() {
      this.message = null;
    }

    /** Returns true if field message is set (has been asigned a value) and false otherwise */
    public boolean isSetMessage() {
      return this.message != null;
    }

    public void setMessageIsSet(boolean value) {
      if (!value) {
        this.message = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          setMessage((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      case MESSAGE:
        return getMessage();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      case MESSAGE:
        return isSetMessage();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setMessage_args)
        return this.equals((setMessage_args)that);
      return false;
    }

    public boolean equals(setMessage_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      boolean this_present_message = true && this.isSetMessage();
      boolean that_present_message = true && that.isSetMessage();
      if (this_present_message || that_present_message) {
        if (!(this_present_message && that_present_message))
          return false;
        if (!this.message.equals(that.message))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setMessage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setMessage_args typedOther = (setMessage_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMessage()).compareTo(typedOther.isSetMessage());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMessage()) {        lastComparison = TBaseHelper.compareTo(this.message, typedOther.message);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MESSAGE
            if (field.type == TType.STRING) {
              this.message = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      if (this.message != null) {
        oprot.writeFieldBegin(MESSAGE_FIELD_DESC);
        oprot.writeString(this.message);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setMessage_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("message:");
      if (this.message == null) {
        sb.append("null");
      } else {
        sb.append(this.message);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setMessage_result implements TBase<setMessage_result, setMessage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setMessage_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setMessage_result.class, metaDataMap);
    }

    public setMessage_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setMessage_result(setMessage_result other) {
    }

    public setMessage_result deepCopy() {
      return new setMessage_result(this);
    }

    @Deprecated
    public setMessage_result clone() {
      return new setMessage_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setMessage_result)
        return this.equals((setMessage_result)that);
      return false;
    }

    public boolean equals(setMessage_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setMessage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setMessage_result typedOther = (setMessage_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setMessage_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMessage_args implements TBase<getMessage_args, getMessage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getMessage_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);

    public String key;
    public String OperationHandleKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getMessage_args.class, metaDataMap);
    }

    public getMessage_args() {
    }

    public getMessage_args(
      String key,
      String OperationHandleKey)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMessage_args(getMessage_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
    }

    public getMessage_args deepCopy() {
      return new getMessage_args(this);
    }

    @Deprecated
    public getMessage_args clone() {
      return new getMessage_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
    }

    public String getKey() {
      return this.key;
    }

    public getMessage_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public getMessage_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getMessage_args)
        return this.equals((getMessage_args)that);
      return false;
    }

    public boolean equals(getMessage_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getMessage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getMessage_args typedOther = (getMessage_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getMessage_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getMessage_result implements TBase<getMessage_result, getMessage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getMessage_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getMessage_result.class, metaDataMap);
    }

    public getMessage_result() {
    }

    public getMessage_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getMessage_result(getMessage_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getMessage_result deepCopy() {
      return new getMessage_result(this);
    }

    @Deprecated
    public getMessage_result clone() {
      return new getMessage_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public getMessage_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getMessage_result)
        return this.equals((getMessage_result)that);
      return false;
    }

    public boolean equals(getMessage_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getMessage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getMessage_result typedOther = (getMessage_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getMessage_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class program_args implements TBase<program_args, program_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("program_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);
    private static final TField BYTES_FIELD_DESC = new TField("bytes", TType.LIST, (short)3);
    private static final TField DESCRIPTION_FIELD_DESC = new TField("description", TType.STRING, (short)4);
    private static final TField TIMEOUT_FIELD_DESC = new TField("timeout", TType.I64, (short)5);

    public String key;
    public String OperationHandleKey;
    public List<ByteBuffer> bytes;
    public String description;
    public long timeout;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey"),
      BYTES((short)3, "bytes"),
      DESCRIPTION((short)4, "description"),
      TIMEOUT((short)5, "timeout");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          case 3: // BYTES
            return BYTES;
          case 4: // DESCRIPTION
            return DESCRIPTION;
          case 5: // TIMEOUT
            return TIMEOUT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMEOUT_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.BYTES, new FieldMetaData("bytes", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.DESCRIPTION, new FieldMetaData("description", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TIMEOUT, new FieldMetaData("timeout", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(program_args.class, metaDataMap);
    }

    public program_args() {
    }

    public program_args(
      String key,
      String OperationHandleKey,
      List<ByteBuffer> bytes,
      String description,
      long timeout)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
      this.bytes = bytes;
      this.description = description;
      this.timeout = timeout;
      setTimeoutIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public program_args(program_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
      if (other.isSetBytes()) {
        List<ByteBuffer> __this__bytes = new ArrayList<ByteBuffer>();
        for (ByteBuffer other_element : other.bytes) {
          ByteBuffer temp_binary_element = ByteBuffer.wrap(new byte[other_element.limit() - other_element.arrayOffset()]);
          System.arraycopy(other_element.array(), other_element.arrayOffset(), temp_binary_element.array(), 0, other_element.limit() - other_element.arrayOffset());
          __this__bytes.add(temp_binary_element);
        }
        this.bytes = __this__bytes;
      }
      if (other.isSetDescription()) {
        this.description = other.description;
      }
      this.timeout = other.timeout;
    }

    public program_args deepCopy() {
      return new program_args(this);
    }

    @Deprecated
    public program_args clone() {
      return new program_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
      this.bytes = null;
      this.description = null;
      setTimeoutIsSet(false);
      this.timeout = 0;
    }

    public String getKey() {
      return this.key;
    }

    public program_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public program_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public int getBytesSize() {
      return (this.bytes == null) ? 0 : this.bytes.size();
    }

    public java.util.Iterator<ByteBuffer> getBytesIterator() {
      return (this.bytes == null) ? null : this.bytes.iterator();
    }

    public void addToBytes(ByteBuffer elem) {
      if (this.bytes == null) {
        this.bytes = new ArrayList<ByteBuffer>();
      }
      this.bytes.add(elem);
    }

    public List<ByteBuffer> getBytes() {
      return this.bytes;
    }

    public program_args setBytes(List<ByteBuffer> bytes) {
      this.bytes = bytes;
      return this;
    }

    public void unsetBytes() {
      this.bytes = null;
    }

    /** Returns true if field bytes is set (has been asigned a value) and false otherwise */
    public boolean isSetBytes() {
      return this.bytes != null;
    }

    public void setBytesIsSet(boolean value) {
      if (!value) {
        this.bytes = null;
      }
    }

    public String getDescription() {
      return this.description;
    }

    public program_args setDescription(String description) {
      this.description = description;
      return this;
    }

    public void unsetDescription() {
      this.description = null;
    }

    /** Returns true if field description is set (has been asigned a value) and false otherwise */
    public boolean isSetDescription() {
      return this.description != null;
    }

    public void setDescriptionIsSet(boolean value) {
      if (!value) {
        this.description = null;
      }
    }

    public long getTimeout() {
      return this.timeout;
    }

    public program_args setTimeout(long timeout) {
      this.timeout = timeout;
      setTimeoutIsSet(true);
      return this;
    }

    public void unsetTimeout() {
      __isset_bit_vector.clear(__TIMEOUT_ISSET_ID);
    }

    /** Returns true if field timeout is set (has been asigned a value) and false otherwise */
    public boolean isSetTimeout() {
      return __isset_bit_vector.get(__TIMEOUT_ISSET_ID);
    }

    public void setTimeoutIsSet(boolean value) {
      __isset_bit_vector.set(__TIMEOUT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      case BYTES:
        if (value == null) {
          unsetBytes();
        } else {
          setBytes((List<ByteBuffer>)value);
        }
        break;

      case DESCRIPTION:
        if (value == null) {
          unsetDescription();
        } else {
          setDescription((String)value);
        }
        break;

      case TIMEOUT:
        if (value == null) {
          unsetTimeout();
        } else {
          setTimeout((Long)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      case BYTES:
        return getBytes();

      case DESCRIPTION:
        return getDescription();

      case TIMEOUT:
        return new Long(getTimeout());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      case BYTES:
        return isSetBytes();
      case DESCRIPTION:
        return isSetDescription();
      case TIMEOUT:
        return isSetTimeout();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof program_args)
        return this.equals((program_args)that);
      return false;
    }

    public boolean equals(program_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      boolean this_present_bytes = true && this.isSetBytes();
      boolean that_present_bytes = true && that.isSetBytes();
      if (this_present_bytes || that_present_bytes) {
        if (!(this_present_bytes && that_present_bytes))
          return false;
        if (!this.bytes.equals(that.bytes))
          return false;
      }

      boolean this_present_description = true && this.isSetDescription();
      boolean that_present_description = true && that.isSetDescription();
      if (this_present_description || that_present_description) {
        if (!(this_present_description && that_present_description))
          return false;
        if (!this.description.equals(that.description))
          return false;
      }

      boolean this_present_timeout = true;
      boolean that_present_timeout = true;
      if (this_present_timeout || that_present_timeout) {
        if (!(this_present_timeout && that_present_timeout))
          return false;
        if (this.timeout != that.timeout)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(program_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      program_args typedOther = (program_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetBytes()).compareTo(typedOther.isSetBytes());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetBytes()) {        lastComparison = TBaseHelper.compareTo(this.bytes, typedOther.bytes);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDescription()).compareTo(typedOther.isSetDescription());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDescription()) {        lastComparison = TBaseHelper.compareTo(this.description, typedOther.description);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTimeout()).compareTo(typedOther.isSetTimeout());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTimeout()) {        lastComparison = TBaseHelper.compareTo(this.timeout, typedOther.timeout);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // BYTES
            if (field.type == TType.LIST) {
              {
                TList _list0 = iprot.readListBegin();
                this.bytes = new ArrayList<ByteBuffer>(_list0.size);
                for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                {
                  ByteBuffer _elem2;
                  _elem2 = iprot.readBinary();
                  this.bytes.add(_elem2);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // DESCRIPTION
            if (field.type == TType.STRING) {
              this.description = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // TIMEOUT
            if (field.type == TType.I64) {
              this.timeout = iprot.readI64();
              setTimeoutIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      if (this.bytes != null) {
        oprot.writeFieldBegin(BYTES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.bytes.size()));
          for (ByteBuffer _iter3 : this.bytes)
          {
            oprot.writeBinary(_iter3);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.description != null) {
        oprot.writeFieldBegin(DESCRIPTION_FIELD_DESC);
        oprot.writeString(this.description);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMEOUT_FIELD_DESC);
      oprot.writeI64(this.timeout);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("program_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("bytes:");
      if (this.bytes == null) {
        sb.append("null");
      } else {
        sb.append(this.bytes);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("description:");
      if (this.description == null) {
        sb.append("null");
      } else {
        sb.append(this.description);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timeout:");
      sb.append(this.timeout);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class program_result implements TBase<program_result, program_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("program_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(program_result.class, metaDataMap);
    }

    public program_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public program_result(program_result other) {
    }

    public program_result deepCopy() {
      return new program_result(this);
    }

    @Deprecated
    public program_result clone() {
      return new program_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof program_result)
        return this.equals((program_result)that);
      return false;
    }

    public boolean equals(program_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(program_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      program_result typedOther = (program_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("program_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class HandleCancel_args implements TBase<HandleCancel_args, HandleCancel_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("HandleCancel_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);

    public String key;
    public String OperationHandleKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(HandleCancel_args.class, metaDataMap);
    }

    public HandleCancel_args() {
    }

    public HandleCancel_args(
      String key,
      String OperationHandleKey)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public HandleCancel_args(HandleCancel_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
    }

    public HandleCancel_args deepCopy() {
      return new HandleCancel_args(this);
    }

    @Deprecated
    public HandleCancel_args clone() {
      return new HandleCancel_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
    }

    public String getKey() {
      return this.key;
    }

    public HandleCancel_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public HandleCancel_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof HandleCancel_args)
        return this.equals((HandleCancel_args)that);
      return false;
    }

    public boolean equals(HandleCancel_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(HandleCancel_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      HandleCancel_args typedOther = (HandleCancel_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("HandleCancel_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class HandleGet_args implements TBase<HandleGet_args, HandleGet_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("HandleGet_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);

    public String key;
    public String OperationHandleKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(HandleGet_args.class, metaDataMap);
    }

    public HandleGet_args() {
    }

    public HandleGet_args(
      String key,
      String OperationHandleKey)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public HandleGet_args(HandleGet_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
    }

    public HandleGet_args deepCopy() {
      return new HandleGet_args(this);
    }

    @Deprecated
    public HandleGet_args clone() {
      return new HandleGet_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
    }

    public String getKey() {
      return this.key;
    }

    public HandleGet_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public HandleGet_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof HandleGet_args)
        return this.equals((HandleGet_args)that);
      return false;
    }

    public boolean equals(HandleGet_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(HandleGet_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      HandleGet_args typedOther = (HandleGet_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("HandleGet_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class HandleGet_result implements TBase<HandleGet_result, HandleGet_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("HandleGet_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(HandleGet_result.class, metaDataMap);
    }

    public HandleGet_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public HandleGet_result(HandleGet_result other) {
    }

    public HandleGet_result deepCopy() {
      return new HandleGet_result(this);
    }

    @Deprecated
    public HandleGet_result clone() {
      return new HandleGet_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof HandleGet_result)
        return this.equals((HandleGet_result)that);
      return false;
    }

    public boolean equals(HandleGet_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(HandleGet_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      HandleGet_result typedOther = (HandleGet_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("HandleGet_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class HandleGetState_args implements TBase<HandleGetState_args, HandleGetState_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("HandleGetState_args");

    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
    private static final TField OPERATION_HANDLE_KEY_FIELD_DESC = new TField("OperationHandleKey", TType.STRING, (short)2);

    public String key;
    public String OperationHandleKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      KEY((short)1, "key"),
      OPERATION_HANDLE_KEY((short)2, "OperationHandleKey");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // KEY
            return KEY;
          case 2: // OPERATION_HANDLE_KEY
            return OPERATION_HANDLE_KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPERATION_HANDLE_KEY, new FieldMetaData("OperationHandleKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(HandleGetState_args.class, metaDataMap);
    }

    public HandleGetState_args() {
    }

    public HandleGetState_args(
      String key,
      String OperationHandleKey)
    {
      this();
      this.key = key;
      this.OperationHandleKey = OperationHandleKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public HandleGetState_args(HandleGetState_args other) {
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetOperationHandleKey()) {
        this.OperationHandleKey = other.OperationHandleKey;
      }
    }

    public HandleGetState_args deepCopy() {
      return new HandleGetState_args(this);
    }

    @Deprecated
    public HandleGetState_args clone() {
      return new HandleGetState_args(this);
    }

    @Override
    public void clear() {
      this.key = null;
      this.OperationHandleKey = null;
    }

    public String getKey() {
      return this.key;
    }

    public HandleGetState_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getOperationHandleKey() {
      return this.OperationHandleKey;
    }

    public HandleGetState_args setOperationHandleKey(String OperationHandleKey) {
      this.OperationHandleKey = OperationHandleKey;
      return this;
    }

    public void unsetOperationHandleKey() {
      this.OperationHandleKey = null;
    }

    /** Returns true if field OperationHandleKey is set (has been asigned a value) and false otherwise */
    public boolean isSetOperationHandleKey() {
      return this.OperationHandleKey != null;
    }

    public void setOperationHandleKeyIsSet(boolean value) {
      if (!value) {
        this.OperationHandleKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case OPERATION_HANDLE_KEY:
        if (value == null) {
          unsetOperationHandleKey();
        } else {
          setOperationHandleKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case KEY:
        return getKey();

      case OPERATION_HANDLE_KEY:
        return getOperationHandleKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case KEY:
        return isSetKey();
      case OPERATION_HANDLE_KEY:
        return isSetOperationHandleKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof HandleGetState_args)
        return this.equals((HandleGetState_args)that);
      return false;
    }

    public boolean equals(HandleGetState_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_OperationHandleKey = true && this.isSetOperationHandleKey();
      boolean that_present_OperationHandleKey = true && that.isSetOperationHandleKey();
      if (this_present_OperationHandleKey || that_present_OperationHandleKey) {
        if (!(this_present_OperationHandleKey && that_present_OperationHandleKey))
          return false;
        if (!this.OperationHandleKey.equals(that.OperationHandleKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(HandleGetState_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      HandleGetState_args typedOther = (HandleGetState_args)other;

      lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetKey()) {        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOperationHandleKey()).compareTo(typedOther.isSetOperationHandleKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOperationHandleKey()) {        lastComparison = TBaseHelper.compareTo(this.OperationHandleKey, typedOther.OperationHandleKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPERATION_HANDLE_KEY
            if (field.type == TType.STRING) {
              this.OperationHandleKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.OperationHandleKey != null) {
        oprot.writeFieldBegin(OPERATION_HANDLE_KEY_FIELD_DESC);
        oprot.writeString(this.OperationHandleKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("HandleGetState_args(");
      boolean first = true;

      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("OperationHandleKey:");
      if (this.OperationHandleKey == null) {
        sb.append("null");
      } else {
        sb.append(this.OperationHandleKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class HandleGetState_result implements TBase<HandleGetState_result, HandleGetState_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("HandleGetState_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(HandleGetState_result.class, metaDataMap);
    }

    public HandleGetState_result() {
    }

    public HandleGetState_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public HandleGetState_result(HandleGetState_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public HandleGetState_result deepCopy() {
      return new HandleGetState_result(this);
    }

    @Deprecated
    public HandleGetState_result clone() {
      return new HandleGetState_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public HandleGetState_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof HandleGetState_result)
        return this.equals((HandleGetState_result)that);
      return false;
    }

    public boolean equals(HandleGetState_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(HandleGetState_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      HandleGetState_result typedOther = (HandleGetState_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("HandleGetState_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
